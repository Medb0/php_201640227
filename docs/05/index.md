# 2019.09.25 (5주차)

## PHP 정리

1. php 에서 다른 코드를 불러올때는 include "코드명"을 사용해서 불러온다. 

   <img src="./img/1.png" alt="1" style="zoom:75%;" />



2. include로 다른 코드를 불러올때 없는 파일을 불러올 경우 warning 이 뜬다. 실행은 되지만 없는 파일은 무시하고 실행된다.![2](./img/2.png)

3. require로 다른 코드를 불러올때는 없는 파일을 불러올 경우 error가 뜨고 실행이 되지 않는다.

   ![3](./img/3.png)

4. require로 다른 코드를 불러올 때 , 경로를 잘 확인해야한다. 경로가 직접 적어주지 않으면 error가 발생한다.

   ![4](./img/4.png)

   이런 식으로 표기를 해주어야 한다.

   ![4](./img/5.png)

5. PHP 표준 권고(PSR) 

- 들여 쓰기는 tab 대신 4칸의 공백 사용
- 닫는 태그(?>) 는 사용하지 않음
- `namespace`  선언뒤에는 한 줄의 공백을 사용하고 여러 개의 use는 줄 공백없이 사용후에 마지막 블록뒤에 한 줄의 공백을 사용할 것 
- 클래스 구문의 여는 괄호는 다음 줄에 사용하고 닫는 괄호는 본문 다음 줄에 사용할 것
- 메소드 구문의 여는 괄호는 다음 줄에 사용하고 닫는 괄호는 본문 다음 줄에 사용할 것
- 가시성과 관련된 키워드인 abstract 과 final 은 모든 메소드와 프로퍼티에 명시적으로 사용하고 제일 먼저 와야 하며 static 구문은 그 후에 위치시킬 것
- if 나 elseif 같은 제어 관련 구문은 제어문 뒤에 한 개의 공백을 두고 그 후에 괄호를 사용하고 조건문을 기술할 것. 함수 호출이나 메소드 호출은 메소드명 뒤에 공백이 있으면 안 됨,
- if 나 elseif 같은 제어 관련 구문의 여는 괄호는 제어문과 같은 줄에 위치해야 함. 닫는 괄호는 본문의 다음 줄에 위치

![6](./img/6.png)



7. 함수를 선언해보자.  함수 선언시에 return으로 반환할 수 있는 값은 하나뿐이기 때문에 두개 이상을 반환할 경우 배열로 반환을 한다.

   반환 받는 변수의 타입을 잘 지정해야 한다.

   ![7](./img/7.png)



8. 함수를 다른 파일로 분리하고 호출한다. include는 부르는만큼 실행되기 때문에 함수를 2번 선언하게 되는데 2번 선언을 하면 에러가 발생한다. 이를 방지하기 위하여 include_once 라는 명령어를 사용하면 같은 include를 한번만 실행하게 되어 함수를 1번만 선언한게 된다.

![8](./img/8.png)

9. 다른 방법으로는 함수안에 function_exists 사용하여 함수가 이미 선언되어있는지를 검사하고 if , else 문으로 실행 및 중복실행을 방지 할 수 있다.

   ![9](./img/9.png)

   

10. php 클래스를 만드는 것은 다른 언어와 비슷하다.

    객체를 생성할 때는 new 키워드 뒤에 클래스명이 붙는다.

    클래스 안의 함수를 사용하기 위해서 보통 다른 언어에서는 '.'을 사용하지만 PHP에서는 '->' 를 사용한다. 

    ![10](./img/10.png)

    

    11. 클래스는 여러개의 함수를 묶을 수 있다. 이것을 캡슐화라고 한다. 물론 변수도 같이 캡슐화를 할 수 있다.

    ![11](./img/11.png)



12. 클래스 안의 변수를 불러올 경우 -> 뒤의 $는 생략하고 클래스안의 변수명만 붙인다.

    클래스에서는 상수로 const만 사용이 가능하고 불러올경우 -> 대신 :: 를 사용한다.

    ![12](./img/12.png)

13.  만약 클래스가 많이 있고 전부 include를 해야할 경우 간단한 코드를 작성해서 쉽게 할 수 있다.

![13](./img/13.png)



14.  this 는 현재 인스턴스화된 클래스를 지칭하는 것이다.

    사용자가 지정한 클래스명으로도 사용할 수 있고 this의 값을 저장해서도 클래스를 사용할 수 있다.

    반환값이 this이면 자기 클래스를 반환하기 때문에 바로 사용할 수 있다. 이것을 메소드 체인이라고 부른다. 함수안에 리턴값을 this로 주면 계속 클래스를 연속해서 사용할 수 있다.

![14](./img/14.png)



15. static 을 붙이면 생성을 하지 않아도 바로 사용 가능하다. 

    다시말해 인스턴스를 만들지 않고 바로 사용하겠다고 허용을 하는 것이다.

    인스턴스를 생성하지 않고 사용시 -> 대신 :: 을 사용하고

    변수에 접근하기 위해서는 $변수명으로 사용한다.

    인스턴스를 생성하면 this 라는 이름이 생기고

    생성을 하지않고 static을 이용해서 사용하면 self 라는 이름이 생긴다.

![15](./img/15.png)



16. PHP의 생성자는 public function __construct() 라고 쓴다. 다른 언어에서는 class 명과 같은 이름으로 만들지만 PHP에서는 고정이다.

    ![생성자](./img/16.png)



17. 인스턴스가 생성이 되면 $this가 생긴다. 생성자에서도 사용이 가능하다.

![생성자](./img/17.png)



18. PHP에서 접근제한자는 public , protected , private 3가지가 있다.

    public은 어떤 클래스에서든 접근이 가능하다.

    private은 다른 클래스에서는 접근이 불가능하고 자기 클래스 내에서만 접근이 가능하다.

    이렇게 다른 클래스에서 접근을 못하게끔하는것을 은닉화라고 한다.

    ![private](./img/18.png)

    protected는 상속받은 클래스까지 접근이 가능하다.

19. 클래스 뒤에 extends 클래스명 을 붙이면 상속을 하게 된다.

    상속을하면 상속받은 클래스는 자기클래스와 부모클래스의  기능을 모두 사용할 수 있게된다.

    ![상속](./img/19.png)

20. 상속받은 자식클래스가 부모클래스에 있는 메소드를 재작성 하는것을 오버라이딩이라고 한다.

    ![오버라이딩](./img/20.png)

    혹시라도 이 코드가 바뀌면 안될경우 final 키워드를 붙인다.

    ![final](./img/21.png)

21. 인터페이스는 클래스를 만들때 꼭 만들어야하는 것을 미리 만드는것이다.

    ![interface](./img/22.png)

    인터페이스를 상속받을시 안에 있는 내용을 만들지 않을 경우 에러가 난다.

    ![interface](./img/23.png)

22. 추상클래스는 인터페이스처럼 미리 만들것을 지정할 수 있고 , 일반 클래스처럼 미리 만들어서 상속해 줄 수 있다.
    ![abstract](./img/24.png)

23. 클래스 안에 새로운 클래스를 끼워넣는 용도로 trait 을 사용한다.

    다시 말해 필요한 부분을 따로 뽑아서 조합하는것이다.

    그리고 trait은 상속이 가능하다.

    ![trait](./img/25.png)

24. 여러개의 클래스를 받아올경우 같은 이름의 클래스가 있을 수 있기때문에 namespace 라는것으로 분류한다.

    그 namespace가 길어질경우 use 키워드를 사용해서 짧게 쓸수 있도록 할 수 있다.

    ![namespace](./img/26.png)

    use 를 따로 이름을 지어서도 사용할 수 있는데 as 키워드를 사용하면 된다.

    ![namespace](./img/27.png)

25. 함수내에서 전역변수를 불러올때 global 키워드를 붙여서 가져오면 사용할 수 있다.

    ![global](./img/28.png)

    전역변수는 배열 속에 담기는데 GLOBALS라는 지정된 값에 들어간다.

    ![globals](./img/29.png)

26. 서버에 지정된 값이 여러개 있는데 그중 REQUEST_URI 를 사용하면 경로가 나온다.

    ![request_uri](./img/30.png)